#!/usr/bin/env sh
set -eu

# TODO:
# 1. CHOOSE -> UPDATE: ALL/BINARY
# 2. Exit early if there's only exit option

# Links to scripts/configs
scripts_url="https://raw.githubusercontent.com/simplex-chat/simplexmq/stable/scripts/main"
scripts_url_systemd_smp="$scripts_url/smp-server.service"
scripts_url_systemd_xftp="$scripts_url/xftp-server.service"
scripts_url_update="$scripts_url/simplex-servers-update"
scripts_url_uninstall="$scripts_url/simplex-servers-uninstall"
scripts_url_stopscript="$scripts_url/simplex-servers-stopscript"

# Default installation paths
path_bin="/usr/local/bin"
path_bin_smp="$path_bin/smp-server"
path_bin_xftp="$path_bin/xftp-server"
path_bin_update="$path_bin/simplex-servers-update"
path_bin_uninstall="$path_bin/simplex-servers-uninstall"
path_bin_stopscript="$path_bin/simplex-servers-stopscript"

path_systemd="/etc/systemd/system"
path_systemd_smp="$path_systemd/smp-server.service"
path_systemd_xftp="$path_systemd/xftp-server.service"

# Temporary paths
path_tmp_bin="/tmp/simplex-servers"
path_tmp_bin_smp="$path_tmp_bin/smp-server"
path_tmp_bin_xftp="$path_tmp_bin/xftp-server"
path_tmp_bin_update="$path_tmp_bin/simplex-servers-update"
path_tmp_bin_uninstall="$path_tmp_bin/simplex-servers-uninstall"
path_tmp_bin_stopscript="$path_tmp_bin/simplex-servers-stopscript"
path_tmp_systemd_smp="$path_tmp_bin/smp-server.service"
path_tmp_systemd_xftp="$path_tmp_bin/xftp-server.service"

path_conf_etc='/etc/opt'
path_conf_info='/etc/opt/simplex-info'

GRN='\033[0;32m'
BLU='\033[1;36m'
YLW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

NL='
'

# Set UPDATE variable globally and only once
UPDATE="${UPDATE:-}"
# Set VER globally and only once
VER="${VER:-latest}"

# Currently, XFTP default to v0.1.0, so it doesn't make sense to check its version

######################
### Misc functions ###
######################

# Erases specified amount of lines (useful to rerender the menu)
erase_lines() {
  for i in $(seq 1 "${1}"); do
    printf '\e[A\e[K'
  done
}

# Replaces every X in variable with incrementing integer
replace_x() {
  counter=0
  result=""
  text="$1"

  # Loop until there are no more "X" characters in the text.
  while [ "${text#*X}" != "$text" ]; do
    # Extract everything before the first "X"
    prefix=${text%%X*}
    # Increment the counter.
    counter=$((counter + 1))
    # Append the prefix and the current counter value to the result.
    result="${result}${prefix}${counter}"
    # Remove the processed part (prefix and the first "X") from text.
    text=${text#*X}
  done

  # Append any remaining text.
  result="${result}${text}"

  printf '%b' "$result"
}

# Checks "sanity" of downloaded thing, e.g. if it's really a script or binary
check_sanity() {
  path="$1"
  criteria="$2"

  case "$criteria" in
    string:*)
      pattern="$(printf '%s' "$criteria" | awk '{print $2}')"
      
      if grep -q "$pattern" "$path"; then
        sane=0
      else
        sane=1
      fi
      ;;
    file:*)
      pattern="$(printf '%s' "$criteria" | awk '{print $2}')"

      if file "$path" | grep -q "$pattern"; then
        sane=0
      else
        sane=1
      fi
      ;;
    *) printf 'Unknown criteria.\n'; sane=1 ;;
  esac

  unset path string

  return "$sane"
}

# Checks if old thing and new thing is different
change_check() {
  old="$1"
  new="$2"

  if [ -x "$new" ] || [ -f "$new" ]; then
    type="$(file $new)"
  else
    type='string'
  fi

  case "$type" in
    *script*)
      if diff -q "$old" "$new" > /dev/null 2>&1; then
        changed=1
      else
        changed=0
      fi
      ;;
    string)
      if [ "$old" = "$new" ]; then
        changed=1
      else
        changed=0
      fi
      ;;
  esac

  return "$changed"
}

##########################
### Misc functions END ###
##########################

#########################
### Support functions ###
#########################

# Updates stored local version of server
update_local_version() {
  server="$1"
  new_ver="$2"
  
  sed -i -- "s|local_version_${server}=.*|local_version_${server}='${new_ver}'|" "$path_conf_info/release"
}

# Sets local/remote versions and "apps" variables
check_versions() {
  # Sets:
  # - ver
  # - bin_url
  # - remote_version
  # - local_version
  # - apps

  case "$VER" in 
    latest)
      bin_url="https://github.com/simplex-chat/simplexmq/releases/latest/download"
      remote_version="$(curl --proto '=https' --tlsv1.2 -sSf -L https://api.github.com/repos/simplex-chat/simplexmq/releases/latest 2>/dev/null | grep -i "tag_name" | awk -F \" '{print $4}')"

      if [ -z "$remote_version" ]; then
        printf "${RED}Something went wrong when ${YLW}resolving the lastest version${NC}: either you don't have connection to Github or you're rate-limited.\n"
        exit 1
      fi
      ;;
    *)
      bin_url="https://github.com/simplex-chat/simplexmq/releases/download/${ver}"
      remote_version="${VER}"
      ;;
  esac

  set +u
  for i in smp xftp; do
    if command -v "$i-server" >/dev/null; then
      apps="$i $apps"
    fi
  done
  set -u

  if [ -z "$apps" ]; then
    printf "${RED}No simplex servers installed! Aborting.${NC}\n"
    exit 1
  fi

  if [ -f "$path_conf_info/release" ]; then
    . "$path_conf_info/release" 2>/dev/null

    for server in $apps; do
      eval "local_version=\$local_version_${server}"

      if [ -z "${local_version}" ]; then
        update_local_version "$server" 'unset'
      fi
    done
  else
    for server in $apps; do
      printf "local_version_${server}=unset\n" > "$path_conf_info/release"
    done
  fi
}

# Checks the distro and sets the urls variables
check_distro() {
  . /etc/os-release

  case "$VERSION_ID" in
    20.04|22.04) : ;;
    24.04) VERSION_ID='22.04' ;;
    *) printf "${RED}Unsupported Ubuntu version!${NC}\nPlease file Github issue with request to support Ubuntu %s: https://github.com/simplex-chat/simplexmq/issues/new\n" "$VERSION_ID" && exit 1 ;;
  esac

  version="$(printf '%s' "$VERSION_ID" | tr '.' '_')"
  arch="$(uname -p)"

  case "$arch" in
    x86_64) arch="$(printf '%s' "$arch" | tr '_' '-')" ;;
    *)  printf "${RED}Unsupported architecture!${NC}\nPlease file Github issue with request to support %s architecture: https://github.com/simplex-chat/simplexmq/issues/new" "$arch" && exit 1 ;;
  esac

  bin_url_smp="$bin_url/smp-server-ubuntu-${version}-${arch}"
  bin_url_xftp="$bin_url/xftp-server-ubuntu-${version}-${arch}"
}

# General checks that must be performed on the initial execution of script
checks() {
  if [ "$(id -u)" -ne 0 ]; then
    printf "This script is intended to be run with root privileges. Please re-run script using sudo.\n"
    exit 1
  fi

  check_versions
  check_distro

  mkdir -p $path_conf_info $path_tmp_bin
}

#############################
### Support functions END ###
#############################

######################
### Main functions ###
######################

# Downloads thing to directory and checks its sanity
download_thing() {
  thing="$1"
  path="$2"
  check_pattern="$3"
  err_msg="$4"
  
  curl --proto '=https' --tlsv1.2 -sSf -L "$thing" -o "$path"

  type="$(file "$path")"

  case "$type" in
    *script*|*executable*) chmod +x "$path" ;;
  esac

  if ! check_sanity "$path" "$check_pattern"; then
    printf "${RED}Something went wrong when downloading ${YLW}%s${NC}: either you don't have connection to Github or you're rate-limited.\n" "$err_msg"
    exit 1
  fi
}

# Downloads all necessary files to temp dir and set update messages for the menu
download_all() {
  download_thing "$scripts_url_update" "$path_tmp_bin_update" 'string: /usr/bin/env' 'Update script'
  if change_check "$path_tmp_bin_update" "$path_bin_update"; then
    msg_scripts="${msg_scripts+$msg_scripts/}${YLW}update${NC}"
  fi

  download_thing "$scripts_url_stopscript" "$path_tmp_bin_stopscript" 'string: /usr/bin/env' 'Stop script'
  if change_check "$path_tmp_bin_stopscript" "$path_bin_stopscript"; then
    msg_scripts="${msg_scripts+$msg_scripts/}${YLW}stop${NC}"
  fi

  download_thing "$scripts_url_uninstall" "$path_tmp_bin_uninstall" 'string: /usr/bin/env' 'Uninstall script'
  if change_check "$path_tmp_bin_uninstall" "$path_bin_uninstall"; then
    msg_scripts="${msg_scripts+$msg_scripts/}${YLW}uninstall${NC}"
  fi

  for i in $apps; do
    service="${i}-server"
    eval "scripts_url_systemd_final=\$scripts_url_systemd_${i}"
    eval "path_tmp_systemd_final=\$path_tmp_systemd_${i}"
    eval "path_systemd_final=\$path_systemd_${i}"
   
    download_thing "$scripts_url_systemd_final" "$path_tmp_systemd_final" 'string: [Unit]' "$service systemd service"
    if change_check "$path_tmp_systemd_final" "$path_systemd_final"; then
      msg_services="${msg_services+$msg_services/}${YLW}$service${NC}"
    fi
  done

  for i in $apps; do
    service="${i}-server"
    eval "local_version=\$local_version_${server}"

    if change_check "$local_version" "$remote_version"; then
      msg_bins="${msg_bins+$msg_bins$NC}  - ${YLW}$service${NC}: from ${BLU}$local_version${NC} to ${BLU}$remote_version${NC}"
    fi
  done
}

changeme_update_scripts() {
  if diff -q "$path_bin_uninstall" "$path_tmp_bin_uninstall" > /dev/null 2>&1; then
    printf -- "- ${YLW}Uninstall script is up-to-date${NC}.\n"
    rm "$path_tmp_bin_uninstall"
  else
    printf -- "- Updating uninstall script..."
    mv "$path_tmp_bin_uninstall" "$path_bin_uninstall"
    printf "${GRN}Done!${NC}\n"
  fi

  if diff -q "$path_bin_stopscript" "$path_tmp_bin_stopscript" > /dev/null 2>&1; then
    printf -- "- ${YLW}Stopscript script is up-to-date${NC}.\n"
    rm "$path_tmp_bin_stopscript"
  else
    printf -- "- Updating stopscript script..."
    mv "$path_tmp_bin_stopscript" "$path_bin_stopscript"
    printf "${GRN}Done!${NC}\n"
  fi

  if diff -q "$path_bin_update" "$path_tmp_bin_update" > /dev/null 2>&1; then
    printf -- "- ${YLW}Update script is up-to-date${NC}.\n"
    rm "$path_tmp_bin_update"
  else
    printf -- "- Updating update script..."
    mv "$path_tmp_bin_update" "$path_bin_update"
    printf "${GRN}Done!${NC}\n"
    printf -- "- Re-executing Update script..."
    exec env CHOOSE="$choose" SCRIPTS_DONE=1 "$path_bin_update"
  fi
}

changeme_update_systemd() {
  if diff -q "$path_systemd" "$path_tmp_systemd" > /dev/null 2>&1; then
    printf -- "- ${YLW}%s service is up-to-date${NC}.\n" "$service"
    rm "$path_tmp_systemd"
  else
    printf -- "- Updating %s service..." "$service"
    mv "$path_tmp_systemd" "$path_systemd"
    systemctl daemon-reload
    printf "${GRN}Done!${NC}\n"
  fi
}

changeme_update_bins() {
  service="${1}-server"
  eval "bin=\$bin_${1}"
  eval "path_bin=\$path_bin_${1}"


  update_bin() {
    printf -- "- Updating %s to %s..." "$service" "$remote_version"

    if ! check_sanity "$path_bin.new" 'file: ELF'; then
      printf "\n${RED}Something went wrong when downloading ${YLW}%s binary${NC}: either you don't have connection to Github or you're rate-limited.\n" "$service"
      rm -f "$path_bin.new"
      exit 1
    else
      mv "$path_bin.new" "$path_bin"
    fi
      
    printf "${GRN}Done!${NC}\n"
  }

  if [ "$local_version" != "$remote_version" ]; then
    update_submenu

# -----------------------------------------------------------
  for i in $apps; do
    service="${i}-server"
    eval "bin_url_final=\$bin_url_${i}"
    eval "path_tmp_bin_final=\$path_tmp_bin_${i}"
    eval "path_bin_final=\$path_bin_${i}"

    download_thing "$bin_url_final" "$path_tmp_bin_final" 'file: ELF' "$service"
    if change_check "$path_tmp_bin_final" "$path_bin_final"; then
      msg_bins="${msg_bins+$msg_bins$NC}  - ${YLW}$service${NC}: from ${BLU}$local_version${NC} to ${BLU}$remote_version${NC}"
    fi
  done
# ------------------------------------------------------------

    if systemctl is-active --quiet "$service"; then
      printf -- "- Stopping %s service..." "$service"
      systemctl stop "$service"
      printf "${GRN}Done!${NC}\n"

      update_bin
      
      printf -- "- Starting %s service..." "$service"
      systemctl start "$service"
      printf "${GRN}Done!${NC}\n"
    else
      update_bin
    fi
  else
    printf -- "- ${YLW}%s is up-to-date${NC}.\n" "$service"
  fi

  set_ver "$1"

  unset service bin path_bin local_version
}

main() {
  printf 'Please wait while script is downloading files...\n'
  download_all
  
  menu_end="${RED}X${NC}) Exit the script${NL}${NL}Selection: "

  set +u
  if [ -n "$msg_scripts" ]; then
    menu_option_misc_raw="${menu_option_misc_raw+${menu_option_misc_raw}${NL}}  - ${msg_scripts} scripts"
  fi

  if [ -n "$msg_services" ]; then
    menu_option_misc_raw="${menu_option_misc_raw+${menu_option_misc_raw}${NL}}  - ${msg_services} services"
  fi

  if [ -n "$menu_option_misc_raw" ]; then
    menu_option_misc="${GRN}X${NC}) Update misc:${NL}${menu_option_misc_raw}${NL}"
  fi

  if [ -n "$msg_bins" ]; then
    menu_option_bins="${GRN}X${NC}) Update binaries:${NL}${msg_bins}${NL}"
    if [ -n "$menu_option_misc" ]; then
      menu_option_all="${GRN}X${NC}) Update all:${NL}${menu_option_misc_raw}${NL}${msg_bins}${NL}"
    fi
  fi

  menu="${menu_option_all:-}${menu_option_bins}${menu_option_misc:-}${menu_end}"

  menu="$(replace_x "$menu")"
  menu_lc=$(printf '%b' "$menu" | tr -cd '\n' | wc -c)
  menu_lc=$((menu_lc + 1))

  selection_check=''
  while [ "$selection_check" != 'pass' ]; do

    printf '%b' "$menu"
    read selection

    line="$(printf '%s' "$menu" | sed 's|\x1b\[[0-9;]*m||g' | grep "$selection)" || :)"

    if [ -n "$line" ]; then
      selection_parse="$(printf '%s' "$line" | sed 's|^.*) ||')"

      case "$selection_parse" in
        'Update misc:')
          update_misc
          ;;
        'Update binaries:')
          update_bins
          ;;
        'Update all:')
          update_all
          ;;
        'Exit the script')
          exit 0
          ;;
        *)
          erase_lines "$menu_lc"
          selection_check='nopass'
          ;;
      esac
    else
      erase_lines "$menu_lc"
      selection_check='nopass'
    fi
  done
}

checks
main "$@"
